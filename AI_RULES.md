# AI 规则文档（最小集）

本项目的 AI 使用与工程规范仅遵循以下两条强制性规则。

## 1) 使用 logger 管理日志
- 全项目禁止直接使用 `print`/`console.*`（调试阶段除外，提交前必须移除/替换）。
- 统一通过项目的 `logger` 组件输出日志（如 `info`、`warn`、`error`、`debug` 等级）。
- 日志需包含：时间戳、等级、来源模块/文件；支持可配置的最小输出等级（如由环境变量控制）。
- 错误与异常必须通过 `logger.error` 记录，并保留关键上下文信息（避免输出密钥/凭证/敏感数据）。
- 若后续接入日志聚合（如 ELK/Datadog），`logger` 需保留结构化字段能力，便于检索与告警。

## 2) 仅使用两个环境文件
- 只创建并使用以下两个环境文件：
  - `env.production`
  - `env.develop`
- 运行与构建流程仅从这两个文件读取配置，不得新增其他环境文件（如 `.env.local`、`.env.test` 等）。
- 两个环境文件的变量键名需保持一致，区别仅在取值。
- 机密信息按团队约定方式安全管理；如必须放入环境文件，确保在版本控制中正确忽略并通过安全渠道分发。

—— 以上为必须遵守的最小规则集。若未来需要扩展（如引入更多日志规范或环境策略），须在此文件中增补并评审。

## 扩展：React + TypeScript 规范（建议 + 少量强制）

以下为在 React + TypeScript 项目中的通用工程规范，默认“建议”，标注【强制】的必须遵守。

### 3) 代码风格与工具链
- 【强制】开启 TypeScript 严格模式：`tsconfig.json` 中启用 `"strict": true`，并启用 `noImplicitAny`、`noUnusedLocals`、`noUnusedParameters`。
- 【强制】禁止无注释的 `any`；确需使用时需局部、最小化且附带注释说明原因与替代计划。
- 统一使用 ESLint + Prettier 管理代码风格与格式；提交前通过 lint 与格式化（建议使用 pre-commit 钩子）。
- 导入顺序：第三方库 → 别名路径 → 相对路径；同组内按字母序；默认使用 `import type` 区分类型导入。
- 建议配置路径别名（如 `@/` 指向 `src/`），避免深层相对路径。

### 4) 目录结构与命名
- `src/` 推荐分层：`app/` 或 `pages/`、`features/`、`components/`、`hooks/`、`services/`、`utils/`、`types/`、`assets/`。
- 组件文件命名使用 `PascalCase`（如 `UserCard.tsx`）；通用工具/Hook 使用 `camelCase`（如 `useAuth.ts`）。
- 每个目录允许 `index.ts/tsx` 作为对外导出入口，但避免多层 `index` 造成来源不明（必要时显式文件名）。
- CSS Modules 或样式命名统一（如 `*.module.scss`），避免全局样式污染。

### 5) 组件开发规范
- 【强制】优先使用函数组件与 Hooks，避免新写类组件。
- Props/State/返回值必须有明确类型定义；组件 Props 使用 `interface`，对外导出的类型统一从 `types/` 或组件同目录 `types.ts` 集中出口。
- 组件拆分遵循单一职责；超过屏幕一页或圈复杂度过高时进行切分。
- 避免在渲染期间创建新函数/对象/正则等，必要时使用 `useCallback` / `useMemo`；不要为“所有东西”滥用 memo。
- 列表渲染 `key` 使用稳定业务主键，避免使用数组下标。
- 表单组件优先使用受控模式；提交与加载态需可视化反馈并具备防抖/节流（按场景）。

### 6) Hooks 使用规范
- 【强制】遵守 Hooks 规则：仅在顶层调用、仅在函数组件/自定义 Hook 中调用，不得在条件/循环内调用。
- 依赖数组必须完整、准确；避免关闭包问题，严禁通过 `// eslint-disable-next-line` 粗暴忽略。
- 自定义 Hook 命名以 `use` 开头；封装输入/输出类型明确，避免返回过大对象（建议按用途拆分）。

### 7) 数据请求与错误处理
- 在 `services/` 统一封装请求客户端与 API 模块；与 UI 解耦，便于复用与测试。
- 超时/重试/取消按业务封装；全局拦截器统一处理认证、通用错误码与刷新令牌策略（如适用）。
- 错误处理优先本地兜底（Toast/重试入口），并通过 `logger.error` 上报关键上下文，避免泄漏敏感信息。
- 仅通过 `env.production`/`env.develop` 提供环境变量；前端可暴露的变量需按脚手架约定前缀（如 Vite 使用 `VITE_`，Next 使用 `NEXT_PUBLIC_`）。

### 8) 状态管理
- 组件内状态用本地 `useState/useReducer`；跨组件共享优先 Lifting/Props，避免滥用全局。
- 全局状态库（如 Redux、Zustand、Jotai 等）按项目统一选型；使用时划清“服务端数据缓存”与“本地全局 UI 状态”。
- 对服务端数据建议使用数据请求库的缓存层（如 SWR/React Query），统一请求/缓存/错误/重试策略与边界处理。

### 9) 性能与可访问性
- 代码分割：路由级/模块级懒加载；首屏关键路径最小化。
- 图片与资源优化：按需尺寸、懒加载、现代格式（如 WebP/AVIF）与响应式。
- 避免不必要的重渲染：合理使用 `memo`、`useMemo`、`useCallback` 与依赖拆分。
- 可访问性（a11y）：语义化标签、表单关联、可聚焦与键盘可达、图片 `alt`、颜色对比度达标。

### 10) 测试与质量保障
- 单元测试优先使用 React Testing Library；谨慎使用快照测试（关注行为而非结构）。
- 对 `utils/`、`hooks/`、`services/` 的核心逻辑保持合理覆盖率；关键分支（错误/边界/并发）需覆盖。
- 端到端测试按重要用户路径配置（登录、核心流程）。

### 11) 提交与代码评审
- 提交信息遵循 Conventional Commits（`feat|fix|docs|style|refactor|perf|test|chore|build|ci|revert`）。
- 单次提交尽量原子化；PR 体量可评审（< 300 行差异为宜），附变更说明与验证方式。
- 必要时附截图/录屏/性能对比；涉及接口/环境变量变更需在 PR 中同步说明。

### 12) 国际化与文案
- 不在组件内硬编码可见文案，集中管理（如 `i18n` 或常量表），避免多处分散。
- 文案/日期/数字/货币遵循本地化格式；避免在逻辑中拼接未转义字符串。

### 13) 安全与合规
- 禁止在前端存储或打印机密数据（令牌、密钥、账号等）；需要时仅短期驻留内存并妥善清理。
- 严禁不可信 HTML 的直接渲染；`dangerouslySetInnerHTML` 仅在严格审计后使用。
- 统一处理 XSS/CSRF/点击劫持等基线风险；同源策略与 CORS 由后端/网关正确配置。

### 14) 日志与埋点（前端）
- 提交前移除 `console.*`；使用项目 `logger` 输出并按环境控制最小等级与上报策略。
- 关键路径埋点（性能、错误、转化）与隐私合规同步评审；埋点键名稳定、可回溯。

### 15) 鉴权与权限控制（可插拔 + RBAC）
- 【强制】预留可插拔鉴权入口：通过环境变量开关控制是否启用鉴权。
  - `VITE_AUTH_DISABLED`: `"true"|"false"`，开发阶段可设为 `true` 放行全部路由；上线前设为 `false`。
  - `VITE_AUTH_BASE`: 鉴权微服务基地址（仅当启用鉴权时使用）。
- 统一的鉴权提供器与守卫：
  - `AuthProvider` 负责用户态与登录/登出占位；`RequireAuth` 用于受保护路由的访问控制。
  - 关闭鉴权时，`RequireAuth` 直接放行；开启鉴权时，未登录跳转到 `/login`，登录后按来源路由返回。
- 路由与菜单的权限声明（RBAC）：
  - 路由支持权限元信息（如 `meta.roles` 或 `meta.permission`），用于 `RequireAuth` 与菜单渲染判断。
  - 菜单（Tab/Item）渲染需依据用户权限进行过滤与禁用态处理，禁止仅依赖前端隐藏实现“伪控制”。
- 权限来源与同步：
  - 用户权限从后端返回（登录/获取用户信息接口），前端仅做缓存与判定，不自行“造权限”。
  - 需要支持“服务端驱动的菜单/路由”扩展（可选），前端适配映射与兜底 404/NoAccess。
- 体验与安全边界：
  - 未授权访问跳转统一落地页（如 `/login` 或 `/403`），保持一致的提示与可回退逻辑。
  - 任何权限判断均需在接口层与网关/后端再次校验，前端仅做体验优化，避免“越权预期”。
- 可观测性：
  - 关键鉴权流程（鉴权启停状态、未授权跳转、权限加载失败）需通过 `logger` 记录重要上下文（避免泄露敏感信息）。
- 配置与扩展建议：
  - 权限标识与业务资源解耦（如 `role`/`scope`/`policy`），避免在 UI 代码中硬编码细粒度权限字符串。
  - 统一封装 `usePermission()` Hook，提供 `can(permission)`/`hasRole(role)` 等判定，路由/菜单/组件均复用。

—— 本节为 React + TypeScript 的工程扩展规范。涉及新增依赖或全局策略变更时，请在评审后再落地执行。
